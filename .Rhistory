# time.
# these come from the model equations.  The following equations are for
# an SITR model.  When you write your own function, replace these with
# your model equations
dS = -S/npop*( beta_w*(Iw + delta*Tw) +beta_r*(Ir + Tr) )
dIw = +S/npop*( beta_w*(Iw + delta*Tw) ) -alpha*Iw -gamma_w*Iw
dTw = +alpha*Iw - phi*Tw -eta*Tw
dIr = +S/npop*( beta_r*(Ir + Tr) ) -alpha*Ir -gamma_r*Ir
dTr = +alpha*Ir + phi*Tw - gamma_r*Tr
dR = +gamma_w*Iw + gamma_r*Ir + eta*Tw +gamma_r*Tr
############################################################################
# vout is an output vector that contains the values of the derivates
# the compartments in the vector on the RHS need to be in the same order as the
# compartments used to fill the x vector!
############################################################################
vout = c(dS,dIw,dTw,dIr,dTr,dR)
list(vout)
})
}
##################################################################################
# this is where we call the lsoda function in the R deSolve library, which
# uses the 4th order Runge-Kutta method to solve the system of ODE's described
# in the derivative_calc_func() function in sir_func.R
##################################################################################
solved_model = as.data.frame(lsoda(inits, vt, model2, model_parameters))
library(deSolve)
##################################################################################
# this is where we call the lsoda function in the R deSolve library, which
# uses the 4th order Runge-Kutta method to solve the system of ODE's described
# in the derivative_calc_func() function in sir_func.R
##################################################################################
solved_model = as.data.frame(lsoda(inits, vt, model2, model_parameters))
head(solved_model)
1 * 0.1
1 * 2
1 * 0.4
100 * 0.4
3/3000
?ppois
1-0.001
log(0.999)
0.001/210
?log
log(2.718282)
log(0.999)
0.0010001/210
10.0010001/1210
-0.0010001/-210
480.2
48*0.2
48*0.5
3000/210
# Initial conditions of our simulations
# Iw_0 is the inital number infected and infectious
# R_0 is the initial number recovered and immune
# S_0 is the initial number susceptible.  Note that npop=S_0+I_0+R_0
##################################################################################
npop = 10000000 * 3
Iw_0 = 1
Tw_0 = 0
Ir_0 = 0
Tr_0 = 0
R_0 = 0
S_0 = npop-Iw_0-Tw_0-Ir_0-Tr_0-R_0
S_0
14/S0
14/S_0
0.00000005
0.0000005
# beta_r      The transmission rate for the drug-resistant variant
#
# alpha       rate in which infected individuals start treatment
# phi         rate in which treated individuals with drug-sensitive variant will
#             develop resistance to the drug
# eta         recovery rate in Tw
# delta       treatment of infectives with a drug-sensitive infection decreases
#             infectivity by a factor delta
# vt          is the vector of time steps at which we want model estimates
##################################################################################
t0 = 0
tend   = 3 * 365
vt = seq(t0,tend,1)
gamma_w = 1/5
gamma_r = 1/5
alpha = 0.0000005 #rate to start treatment ( I think this will be dependent on
# the population size of I)
phi = 0.000005 #rate to develop drug-resistant mutations (see my notes)
delta = 0.05 #decrease on infectivity (let's say it will descrese infectivity by half)
eta = 1/5 #recovery rate in Tw (see notes)
R_w = 1.19
R_w = beta_w*N*(1/(gamma_w + alpha) + (delta*alpha/(gamma_w + alpha) * 1/(eta + phi))) +
(beta_r*N/gamma_w * 0.5) *(alpha/(gamma_w + alpha)) * phi/(eta+phi)
R_w = 1.19 #(Elliot et al 2022 Science) All positives December only
beta_w= R_w*N*(1/(gamma_w + alpha) + (delta*alpha/(gamma_w + alpha) * 1/(eta + phi))) +
(beta_w * 0.5*N/gamma_r) *(alpha/(gamma_w + alpha)) * phi/(eta+phi)
beta_w= R_w*npop*(1/(gamma_w + alpha) + (delta*alpha/(gamma_w + alpha) * 1/(eta + phi))) +
(beta_w * 0.5*npop/gamma_r) *(alpha/(gamma_w + alpha)) * phi/(eta+phi)
beta_w
R_w
npop
gamma_w
beta_w = (R_w/npop) * (1/((1/(gamma_w + alpha) + elta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) + phi/(eta + phi))))
beta_w = (R_w/npop) * (1/((1/(gamma_w + alpha) + eta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) + phi/(eta + phi))))
beta_w
beta_r = beta_w * 0.5
beta_w = (R_w/npop) * (1/((1/(gamma_w + alpha) + eta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) + phi/(eta + phi))))
beta_r = beta_w * 0.5
beta_r
beta_w
beta_w/2
##################################################################################
# fill named vectors with our parameter values and initial conditions
##################################################################################
model_parameters = c(gamma_w = gamma_w,
gamma_r = gamma_r,
beta_w = beta_w,
beta_r = beta_r,
pi = pi,
alpha = alpha,
eta = eta,
delta = delta)
inits = c(S = S_0,
Iw = Iw_0,
Tw = Tw_0,
Ir = Ir_0,
Tr = Tr_0,
R = R_0)
##################################################################################
# this is where we call the lsoda function in the R deSolve library, which
# uses the 4th order Runge-Kutta method to solve the system of ODE's described
# in the derivative_calc_func() function in sir_func.R
##################################################################################
solved_model = as.data.frame(lsoda(inits, vt, model2, model_parameters))
library(deSolve)
##################################################################################
# this is where we call the lsoda function in the R deSolve library, which
# uses the 4th order Runge-Kutta method to solve the system of ODE's described
# in the derivative_calc_func() function in sir_func.R
##################################################################################
solved_model = as.data.frame(lsoda(inits, vt, model2, model_parameters))
##################################################################################
model2=function(t, x, model_parameters){
# The vector x is the same length as the number of compartments.  In your main
# program you identify which compartment corresponds to which element of x.
# You need to make sure that these are in the same order.
S = x[1]
Iw = x[2]
Tw = x[3]
Ir = x[4]
Tr = x[5]
R = x[6]
# model_parameters is a list object, filled in the main program, and passed
# Keep this next line the same when you are writing your own function to
# solve a system of ODE's
with(as.list(model_parameters),{
# calculate the population size, which for our model is
# npop = S+Iw+Tw+Ir+Tr+R
# we will need this to calculate our model derivatives below
npop = S+Iw+Tw+Ir+Tr+R
# Now give the expressions for the derivatives of S, Iw, Ir, Tw, Tr, R with
# time.
# these come from the model equations.  The following equations are for
# an SITR model.  When you write your own function, replace these with
# your model equations
dS = -S/npop*( beta_w*(Iw + delta*Tw) +beta_r*(Ir + Tr) )
dIw = +S/npop*( beta_w*(Iw + delta*Tw) ) -alpha*Iw -gamma_w*Iw
dTw = +alpha*Iw - phi*Tw -eta*Tw
dIr = +S/npop*( beta_r*(Ir + Tr) ) -alpha*Ir -gamma_r*Ir
dTr = +alpha*Ir + phi*Tw - gamma_r*Tr
dR = +gamma_w*Iw + gamma_r*Ir + eta*Tw +gamma_r*Tr
############################################################################
# vout is an output vector that contains the values of the derivates
# the compartments in the vector on the RHS need to be in the same order as the
# compartments used to fill the x vector!
############################################################################
vout = c(dS,dIw,dTw,dIr,dTr,dR)
list(vout)
})
}
##################################################################################
# this is where we call the lsoda function in the R deSolve library, which
# uses the 4th order Runge-Kutta method to solve the system of ODE's described
# in the derivative_calc_func() function in sir_func.R
##################################################################################
solved_model = as.data.frame(lsoda(inits, vt, model2, model_parameters))
solved_model
#             5=cyan
#             6=magenta
#             7=yellow
#             8=gray
#
# Let's plot the prevalence first, which is the fraction infected at each
# point in time
# Here I calculate the ylimits on the plot to be 40% larger than the largest
# value of vI/npop
##################################################################################
ymax = 1.4*max(vIw/npop)
plot(vtime,vIw/npop,type="l",xlab="time",ylab="fraction infected",ylim=c(0,ymax),lwd=3,col=4,main="Infected")
##################################################################################
# let's fill some vectors with the results, just because I don't want to have to
# type "solved_model" over and over again....
##################################################################################
vS = solved_model$S
vIw = solved_model$Iw
vIr = solved_model$Ir
vTw = solved_model$Tw
vTr = solved_model$Tr
vR = solved_model$R
vtime = solved_model$time
vnpop = vS+vIw+vIr+vTw+vTr+vR
#             5=cyan
#             6=magenta
#             7=yellow
#             8=gray
#
# Let's plot the prevalence first, which is the fraction infected at each
# point in time
# Here I calculate the ylimits on the plot to be 40% larger than the largest
# value of vI/npop
##################################################################################
ymax = 1.4*max(vIw/npop)
plot(vtime,vIw/npop,type="l",xlab="time",ylab="fraction infected",ylim=c(0,ymax),lwd=3,col=4,main="Infected")
# beta_r      The transmission rate for the drug-resistant variant
#
# alpha       rate in which infected individuals start treatment
# phi         rate in which treated individuals with drug-sensitive variant will
#             develop resistance to the drug
# eta         recovery rate in Tw
# delta       treatment of infectives with a drug-sensitive infection decreases
#             infectivity by a factor delta
# vt          is the vector of time steps at which we want model estimates
##################################################################################
t0 = 0
tend   = 10 * 365
vt = seq(t0,tend,1)
gamma_w = 1/5
gamma_r = 1/5
alpha = 0.0000005 #rate to start treatment ( I think this will be dependent on
# the population size of I)
phi = 0.000005 #rate to develop drug-resistant mutations (see my notes)
delta = 0.05 #decrease on infectivity (let's say it will descrese infectivity by half)
eta = 1/5 #recovery rate in Tw (see notes)
R_w = 1.19 #(Elliot et al 2022 Science) All positives December only
beta_w = (R_w/npop) * (1/((1/(gamma_w + alpha) + eta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) + phi/(eta + phi))))
beta_r = beta_w * 0.5
beta_r
##################################################################################
# fill named vectors with our parameter values and initial conditions
##################################################################################
model_parameters = c(gamma_w = gamma_w,
gamma_r = gamma_r,
beta_w = beta_w,
beta_r = beta_r,
pi = pi,
alpha = alpha,
eta = eta,
delta = delta)
inits = c(S = S_0,
Iw = Iw_0,
Tw = Tw_0,
Ir = Ir_0,
Tr = Tr_0,
R = R_0)
rm(solved_model)
##################################################################################
# this is where we call the lsoda function in the R deSolve library, which
# uses the 4th order Runge-Kutta method to solve the system of ODE's described
# in the derivative_calc_func() function in sir_func.R
##################################################################################
solved_model = as.data.frame(lsoda(inits, vt, model2, model_parameters))
##################################################################################
# let's fill some vectors with the results, just because I don't want to have to
# type "solved_model" over and over again....
##################################################################################
vS = solved_model$S
vIw = solved_model$Iw
vIr = solved_model$Ir
vTw = solved_model$Tw
vTr = solved_model$Tr
vR = solved_model$R
vtime = solved_model$time
vnpop = vS+vIw+vIr+vTw+vTr+vR
#             5=cyan
#             6=magenta
#             7=yellow
#             8=gray
#
# Let's plot the prevalence first, which is the fraction infected at each
# point in time
# Here I calculate the ylimits on the plot to be 40% larger than the largest
# value of vI/npop
##################################################################################
ymax = 1.4*max(vIw/npop)
plot(vtime,vIw/npop,type="l",xlab="time",ylab="fraction infected",ylim=c(0,ymax),lwd=3,col=4,main="Infected")
(R_w/npop)
# Initial conditions of our simulations
# Iw_0 is the inital number infected and infectious
# R_0 is the initial number recovered and immune
# S_0 is the initial number susceptible.  Note that npop=S_0+I_0+R_0
##################################################################################
npop = 10000000
Iw_0 = 1
Tw_0 = 0
Ir_0 = 0
Tr_0 = 0
R_0 = 0
S_0 = npop-Iw_0-Tw_0-Ir_0-Tr_0-R_0
# beta_r      The transmission rate for the drug-resistant variant
#
# alpha       rate in which infected individuals start treatment
# phi         rate in which treated individuals with drug-sensitive variant will
#             develop resistance to the drug
# eta         recovery rate in Tw
# delta       treatment of infectives with a drug-sensitive infection decreases
#             infectivity by a factor delta
# vt          is the vector of time steps at which we want model estimates
##################################################################################
t0 = 0
tend   = 10 * 365
vt = seq(t0,tend,1)
gamma_w = 1/5
gamma_r = 1/5
alpha = 0.0000005 #rate to start treatment ( I think this will be dependent on
# the population size of I)
phi = 0.000005 #rate to develop drug-resistant mutations (see my notes)
delta = 0.05 #decrease on infectivity (let's say it will descrese infectivity by half)
eta = 1/5 #recovery rate in Tw (see notes)
R_w = 1.19 #(Elliot et al 2022 Science) All positives December only
beta_w = (R_w/npop) * (1/((1/(gamma_w + alpha) + eta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) + phi/(eta + phi))))
beta_r = beta_w * 0.5
##################################################################################
# fill named vectors with our parameter values and initial conditions
##################################################################################
model_parameters = c(gamma_w = gamma_w,
gamma_r = gamma_r,
beta_w = beta_w,
beta_r = beta_r,
pi = pi,
alpha = alpha,
eta = eta,
delta = delta)
inits = c(S = S_0,
Iw = Iw_0,
Tw = Tw_0,
Ir = Ir_0,
Tr = Tr_0,
R = R_0)
##################################################################################
# this is where we call the lsoda function in the R deSolve library, which
# uses the 4th order Runge-Kutta method to solve the system of ODE's described
# in the derivative_calc_func() function in sir_func.R
##################################################################################
solved_model = as.data.frame(lsoda(inits, vt, model2, model_parameters))
#             5=cyan
#             6=magenta
#             7=yellow
#             8=gray
#
# Let's plot the prevalence first, which is the fraction infected at each
# point in time
# Here I calculate the ylimits on the plot to be 40% larger than the largest
# value of vI/npop
##################################################################################
ymax = 1.4*max(vIw/npop)
plot(vtime,vIw/npop,type="l",xlab="time",ylab="fraction infected",ylim=c(0,ymax),lwd=3,col=4,main="Infected")
had(solved_model)
head(solved_model)
tail(solved_model)
beta_w = (R_w/npop) * 1/((1/(gamma_w + alpha) + eta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) * phi/(eta + phi)))
beta_w
beta_w = (R_w/npop) * 1/((1/(gamma_w + alpha) + eta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) + phi/(eta + phi)))
beta_w
1/((1/(gamma_w + alpha) + eta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) * phi/(eta + phi)))
(R_w/npop)
1.19e-07/ (R_w/npop)
(R_w/npop)
1.19e-07 * 0.2000004
beta_w = (R_w/npop) * 1/((1/(gamma_w + alpha) + eta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) * phi/(eta + phi)))
beta_r = beta_w * 0.5
# the population size of I)
phi = 14 #rate to develop drug-resistant mutations (see my notes)
beta_w = (R_w/npop) * 1/((1/(gamma_w + alpha) + eta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) * phi/(eta + phi)))
beta_w
phi
(eta + phi)
1/((1/(gamma_w + alpha) + eta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) * phi/(eta + phi)))
((1/(gamma_w + alpha) + eta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) * phi/(eta + phi)))
npop/R_w
8403361 * 4.999994
1/42016755
beta_w = (R_w/npop) * 1/((1/(gamma_w + alpha) + eta*alpha/(gamma_w + alpha) * 1/(eta + phi)) + (0.5/gamma_r * alpha/(gamma_w + alpha) * phi/(eta + phi)))
beta_r = beta_w * 0.5
##################################################################################
# fill named vectors with our parameter values and initial conditions
##################################################################################
model_parameters = c(gamma_w = gamma_w,
gamma_r = gamma_r,
beta_w = beta_w,
beta_r = beta_r,
pi = pi,
alpha = alpha,
eta = eta,
delta = delta)
inits = c(S = S_0,
Iw = Iw_0,
Tw = Tw_0,
Ir = Ir_0,
Tr = Tr_0,
R = R_0)
##################################################################################
# this is where we call the lsoda function in the R deSolve library, which
# uses the 4th order Runge-Kutta method to solve the system of ODE's described
# in the derivative_calc_func() function in sir_func.R
##################################################################################
solved_model = as.data.frame(lsoda(inits, vt, model2, model_parameters))
head(solved_model)
tail(solved_model)
##################################################################################
model2=function(t, x, model_parameters){
# The vector x is the same length as the number of compartments.  In your main
# program you identify which compartment corresponds to which element of x.
# You need to make sure that these are in the same order.
S = x[1]
Iw = x[2]
Tw = x[3]
Ir = x[4]
Tr = x[5]
R = x[6]
# model_parameters is a list object, filled in the main program, and passed
# Keep this next line the same when you are writing your own function to
# solve a system of ODE's
with(as.list(model_parameters),{
# calculate the population size, which for our model is
# npop = S+Iw+Tw+Ir+Tr+R
# we will need this to calculate our model derivatives below
npop = S+Iw+Tw+Ir+Tr+R
# Now give the expressions for the derivatives of S, Iw, Ir, Tw, Tr, R with
# time.
# these come from the model equations.  The following equations are for
# an SITR model.  When you write your own function, replace these with
# your model equations
#dIw = +S/npop*( beta_w*(Iw + delta*Tw) ) -alpha*Iw -gamma_w*Iw
#dS = -S/npop*( beta_w*(Iw + delta*Tw) +beta_r*(Ir + Tr) )
#dTw = +alpha*Iw - phi*Tw -eta*Tw
#dIr = +S/npop*( beta_r*(Ir + Tr) ) -alpha*Ir -gamma_r*Ir
#dTr = +alpha*Ir + phi*Tw - gamma_r*Tr
#dR = +gamma_w*Iw + gamma_r*Ir + eta*Tw +gamma_r*Tr
dS = -S*( beta_w*(Iw + delta*Tw) +beta_r*(Ir + Tr) )
dIw = +S*( beta_w*(Iw + delta*Tw) ) -alpha*Iw -gamma_w*Iw
dTw = +alpha*Iw - phi*Tw -eta*Tw
dIr = +S*( beta_r*(Ir + Tr) ) -alpha*Ir -gamma_r*Ir
dTr = +alpha*Ir + phi*Tw - gamma_r*Tr
dR = +gamma_w*Iw + gamma_r*Ir + eta*Tw +gamma_r*Tr
############################################################################
# vout is an output vector that contains the values of the derivates
# the compartments in the vector on the RHS need to be in the same order as the
# compartments used to fill the x vector!
############################################################################
vout = c(dS,dIw,dTw,dIr,dTr,dR)
list(vout)
})
}
##################################################################################
# fill named vectors with our parameter values and initial conditions
##################################################################################
model_parameters = c(gamma_w = gamma_w,
gamma_r = gamma_r,
beta_w = beta_w,
beta_r = beta_r,
pi = pi,
alpha = alpha,
eta = eta,
delta = delta)
inits = c(S = S_0,
Iw = Iw_0,
Tw = Tw_0,
Ir = Ir_0,
Tr = Tr_0,
R = R_0)
##################################################################################
# this is where we call the lsoda function in the R deSolve library, which
# uses the 4th order Runge-Kutta method to solve the system of ODE's described
# in the derivative_calc_func() function in sir_func.R
##################################################################################
solved_model = as.data.frame(lsoda(inits, vt, model2, model_parameters))
##################################################################################
# let's fill some vectors with the results, just because I don't want to have to
# type "solved_model" over and over again....
##################################################################################
vS = solved_model$S
vIw = solved_model$Iw
vIr = solved_model$Ir
vTw = solved_model$Tw
vTr = solved_model$Tr
vR = solved_model$R
vtime = solved_model$time
vnpop = vS+vIw+vIr+vTw+vTr+vR
tail(solved_model)
#             5=cyan
#             6=magenta
#             7=yellow
#             8=gray
#
# Let's plot the prevalence first, which is the fraction infected at each
# point in time
# Here I calculate the ylimits on the plot to be 40% larger than the largest
# value of vI/npop
##################################################################################
ymax = 1.4*max(vIw/npop)
plot(vtime,vIw/npop,type="l",xlab="time",ylab="fraction infected",ylim=c(0,ymax),lwd=3,col=4,main="Infected")
ymax = 1.4*max(vIw)
plot(vtime,vIw,type="l",xlab="time",ylab="fraction infected",ylim=c(0,ymax),lwd=3,col=4,main="Infected")
